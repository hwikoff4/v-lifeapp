"use server"

import { revalidatePath } from "next/cache"
import { createClient, getAuthUser } from "@/lib/supabase/server"

type WorkoutMode = "sets" | "rounds"

interface WorkoutExerciseDetail {
  workoutExerciseId: string
  exerciseId: string
  name: string
  category: string | null
  sets: number
  reps: string
  restSeconds: number
  completed: boolean
  completedSets: number
}

export interface ActiveWorkoutPayload {
  workoutId: string
  name: string
  mode: WorkoutMode
  workoutType: string | null
  durationMinutes: number | null
  exercises: WorkoutExerciseDetail[]
}

const STRENGTH_TEMPLATE = [
  { name: "Bench Press", sets: 4, reps: "8-10", restSeconds: 90, order: 1 },
  { name: "Pull-Ups", sets: 3, reps: "8-10", restSeconds: 90, order: 2 },
  { name: "Shoulder Press", sets: 3, reps: "10-12", restSeconds: 60, order: 3 },
  { name: "Bicep Curls", sets: 3, reps: "12", restSeconds: 60, order: 4 },
  { name: "Tricep Extensions", sets: 3, reps: "12", restSeconds: 60, order: 5 },
] as const

const exerciseCache = new Map<string, string>()

async function getExerciseId(name: string, supabase: Awaited<ReturnType<typeof createClient>>) {
  if (exerciseCache.has(name)) {
    return exerciseCache.get(name)!
  }

  const { data, error } = await supabase.from("exercises").select("id").eq("name", name).maybeSingle()
  if (error || !data) {
    throw new Error(`Exercise ${name} not found in catalog`)
  }
  exerciseCache.set(name, data.id)
  return data.id
}

async function createDefaultWorkout(userId: string, supabase: Awaited<ReturnType<typeof createClient>>) {
  const { data: workout, error } = await supabase
    .from("workouts")
    .insert({
      user_id: userId,
      name: "Upper Body Power",
      description: "Strength session auto-generated by V-Life",
      workout_type: "strength",
      duration_minutes: 45,
      mode: "sets",
    })
    .select("id")
    .single()

  if (error || !workout) {
    throw new Error("Unable to create default workout")
  }

  const rows = []
  for (const entry of STRENGTH_TEMPLATE) {
    const exerciseId = await getExerciseId(entry.name, supabase)
    rows.push({
      workout_id: workout.id,
      exercise_id: exerciseId,
      order_index: entry.order,
      sets: entry.sets,
      reps: entry.reps,
      rest_seconds: entry.restSeconds,
    })
  }

  await supabase.from("workout_exercises").insert(rows)
  return workout.id
}

export async function getActiveWorkout(): Promise<ActiveWorkoutPayload | null> {
  const { user, error } = await getAuthUser()
  if (error || !user) {
    return null
  }

  const supabase = await createClient()
  let { data: workout } = await supabase
    .from("workouts")
    .select("id, name, workout_type, duration_minutes, mode, completed")
    .eq("user_id", user.id)
    .eq("completed", false)
    .order("created_at", { ascending: false })
    .limit(1)
    .maybeSingle()

  if (!workout) {
    const workoutId = await createDefaultWorkout(user.id, supabase)
    const { data: created } = await supabase
      .from("workouts")
      .select("id, name, workout_type, duration_minutes, mode, completed")
      .eq("id", workoutId)
      .maybeSingle()
    workout = created || null
  }

  if (!workout) return null

  const { data: exercises } = await supabase
    .from("workout_exercises")
    .select(
      `
      id,
      exercise_id,
      sets,
      reps,
      rest_seconds,
      completed,
      completed_sets,
      order_index,
      exercises (
        name,
        category
      )
    `,
    )
    .eq("workout_id", workout.id)
    .order("order_index", { ascending: true })

  if (!exercises) return null

  const formatted: WorkoutExerciseDetail[] = exercises.map((exercise) => ({
    workoutExerciseId: exercise.id,
    exerciseId: exercise.exercise_id,
    name: exercise.exercises?.name || "Exercise",
    category: exercise.exercises?.category || null,
    sets: exercise.sets || 0,
    reps: exercise.reps || "",
    restSeconds: exercise.rest_seconds || 60,
    completed: exercise.completed ?? false,
    completedSets: exercise.completed_sets || 0,
  }))

  return {
    workoutId: workout.id,
    name: workout.name,
    workoutType: workout.workout_type,
    durationMinutes: workout.duration_minutes,
    mode: (workout.mode as WorkoutMode) || "sets",
    exercises: formatted,
  }
}

interface LogSetInput {
  workoutExerciseId: string
  workoutId: string
  exerciseId: string
  setNumber: number
  totalSets: number
  weight: number
  reps: number
  unit: "lbs" | "kg"
}

export async function logExerciseSet(payload: LogSetInput) {
  const { user, error } = await getAuthUser()
  if (error || !user) {
    return { success: false, error: "Not authenticated" }
  }

  const supabase = await createClient()
  const { error: logError } = await supabase.from("exercise_logs").insert({
    user_id: user.id,
    workout_id: payload.workoutId,
    exercise_id: payload.exerciseId,
    set_number: payload.setNumber,
    reps: payload.reps,
    weight: payload.weight,
    notes: payload.unit,
  })

  if (logError) {
    console.error("[Workout] Failed to log set:", logError)
    return { success: false, error: "Unable to record set" }
  }

  const isComplete = payload.setNumber >= payload.totalSets
  const { error: updateError } = await supabase
    .from("workout_exercises")
    .update({
      completed_sets: payload.setNumber,
      completed: isComplete,
    })
    .eq("id", payload.workoutExerciseId)
    .eq("workout_id", payload.workoutId)

  if (updateError) {
    console.error("[Workout] Failed to update exercise:", updateError)
    return { success: false, error: "Unable to update exercise" }
  }

  revalidatePath("/fitness")
  return { success: true, completed: isComplete }
}

export async function completeWorkout(workoutId: string) {
  const { user, error } = await getAuthUser()
  if (error || !user) {
    return { success: false, error: "Not authenticated" }
  }

  const supabase = await createClient()
  const { error: updateError } = await supabase
    .from("workouts")
    .update({ completed: true, completed_at: new Date().toISOString() })
    .eq("id", workoutId)
    .eq("user_id", user.id)

  if (updateError) {
    console.error("[Workout] Failed to complete workout:", updateError)
    return { success: false, error: "Unable to complete workout" }
  }

  revalidatePath("/fitness")
  return { success: true }
}

export async function refreshTrainingPlan() {
  const { user, error } = await getAuthUser()
  if (error || !user) {
    return { success: false, error: "Not authenticated" }
  }

  const supabase = await createClient()
  const { data: event } = await supabase
    .from("plan_refresh_events")
    .insert({
      user_id: user.id,
      status: "processing",
      message: "Plan refresh requested from dashboard",
    })
    .select("id")
    .single()

  try {
    await createDefaultWorkout(user.id, supabase)
    await supabase
      .from("plan_refresh_events")
      .update({ status: "completed", completed_at: new Date().toISOString(), message: "New training block generated" })
      .eq("id", event.id)
  } catch (err) {
    await supabase
      .from("plan_refresh_events")
      .update({ status: "failed", message: "Unable to refresh plan" })
      .eq("id", event.id)
    console.error("[Workout] Plan refresh failed:", err)
    return { success: false, error: "Failed to refresh plan" }
  }

  revalidatePath("/dashboard")
  revalidatePath("/fitness")
  return { success: true }
}

export interface WorkoutOverview {
  weeklyWorkoutData: Array<{ week: string; workouts: number; volume: number; cardioMinutes: number }>
  exerciseCompletionData: Array<{ day: string; completed: number; total: number }>
  totalWorkoutsThisMonth: number
  avgWorkoutsPerWeek: number
  workoutChange: number
  volumeChange: number
  cardioChange: number
}

export async function getWorkoutOverview(): Promise<WorkoutOverview> {
  const { user, error } = await getAuthUser()
  if (error || !user) {
    return {
      weeklyWorkoutData: [],
      exerciseCompletionData: [],
      totalWorkoutsThisMonth: 0,
      avgWorkoutsPerWeek: 0,
      workoutChange: 0,
      volumeChange: 0,
      cardioChange: 0,
    }
  }

  const supabase = await createClient()
  const startRange = new Date()
  startRange.setDate(startRange.getDate() - 35)

  const { data: workouts } = await supabase
    .from("workouts")
    .select("id, workout_type, duration_minutes, completed, created_at")
    .eq("user_id", user.id)
    .gte("created_at", startRange.toISOString())

  const { data: logs } = await supabase
    .from("exercise_logs")
    .select("workout_id, reps, weight")
    .eq("user_id", user.id)
    .gte("logged_at", startRange.toISOString())

  const volumeByWorkout = new Map<string, number>()
  ;(logs || []).forEach((log) => {
    const volume = Number(log.weight || 0) * Number(log.reps || 0)
    volumeByWorkout.set(log.workout_id, (volumeByWorkout.get(log.workout_id) || 0) + volume)
  })

  const weeklyMap = new Map<string, { workouts: number; volume: number; cardioMinutes: number }>()
  ;(workouts || []).forEach((session) => {
    const created = new Date(session.created_at!)
    const weekKey = `${created.getFullYear()}-${getWeekNumber(created)}`
    if (!weeklyMap.has(weekKey)) {
      weeklyMap.set(weekKey, { workouts: 0, volume: 0, cardioMinutes: 0 })
    }
    const bucket = weeklyMap.get(weekKey)!
    bucket.workouts += 1
    bucket.volume += volumeByWorkout.get(session.id) || 0
    if (session.workout_type === "cardio") {
      bucket.cardioMinutes += session.duration_minutes || 0
    }
  })

  const weeklyWorkoutData = Array.from(weeklyMap.entries())
    .sort((a, b) => a[0].localeCompare(b[0]))
    .map(([key, value], idx) => ({
      week: `Week ${idx + 1}`,
      ...value,
    }))

  const totalWorkoutsThisMonth = (workouts || []).filter((session) => {
    const completedAt = new Date(session.created_at!)
    const now = new Date()
    return completedAt.getMonth() === now.getMonth() && completedAt.getFullYear() === now.getFullYear()
  }).length

  const lastTwo = weeklyWorkoutData.slice(-2)
  const workoutChange =
    lastTwo.length === 2 && lastTwo[0].workouts > 0
      ? ((lastTwo[1].workouts - lastTwo[0].workouts) / lastTwo[0].workouts) * 100
      : 0
  const volumeChange =
    lastTwo.length === 2 && lastTwo[0].volume > 0 ? ((lastTwo[1].volume - lastTwo[0].volume) / lastTwo[0].volume) * 100 : 0
  const cardioChange =
    lastTwo.length === 2 && lastTwo[0].cardioMinutes > 0
      ? ((lastTwo[1].cardioMinutes - lastTwo[0].cardioMinutes) / lastTwo[0].cardioMinutes) * 100
      : 0

  const avgWorkoutsPerWeek =
    weeklyWorkoutData.length > 0
      ? weeklyWorkoutData.reduce((sum, week) => sum + week.workouts, 0) / weeklyWorkoutData.length
      : 0

  const exerciseCompletionData = await buildDailyCompletion(user.id, supabase)

  return {
    weeklyWorkoutData,
    exerciseCompletionData,
    totalWorkoutsThisMonth,
    avgWorkoutsPerWeek: Number(avgWorkoutsPerWeek.toFixed(1)),
    workoutChange,
    volumeChange,
    cardioChange,
  }
}

async function buildDailyCompletion(userId: string, supabase: Awaited<ReturnType<typeof createClient>>) {
  const start = new Date()
  start.setDate(start.getDate() - 6)
  start.setHours(0, 0, 0, 0)
  const end = new Date()
  end.setHours(23, 59, 59, 999)

  const { data } = await supabase
    .from("workout_exercises")
    .select(
      `
      completed,
      created_at,
      workouts!inner (
        user_id,
        created_at
      )
    `,
    )
    .eq("workouts.user_id", userId)
    .gte("workouts.created_at", start.toISOString())
    .lte("workouts.created_at", end.toISOString())

  const days: Array<{ day: string; completed: number; total: number }> = []
  for (let i = 0; i < 7; i++) {
    const day = new Date(start)
    day.setDate(start.getDate() + i)
    const label = day.toLocaleDateString(undefined, { weekday: "short" })
    const stats = { day: label, completed: 0, total: 0 }
    ;(data || []).forEach((exercise) => {
      const exerciseDate = new Date(exercise.created_at || exercise.workouts?.created_at || "")
      if (
        exerciseDate.getFullYear() === day.getFullYear() &&
        exerciseDate.getMonth() === day.getMonth() &&
        exerciseDate.getDate() === day.getDate()
      ) {
        stats.total += 1
        if (exercise.completed) stats.completed += 1
      }
    })
    days.push(stats)
  }

  return days
}

function getWeekNumber(date: Date) {
  const target = new Date(date.valueOf())
  const dayNr = (date.getDay() + 6) % 7
  target.setDate(target.getDate() - dayNr + 3)
  const firstThursday = target.valueOf()
  target.setMonth(0, 1)
  if (target.getDay() !== 4) {
    target.setMonth(0, 1 + ((4 - target.getDay() + 7) % 7))
  }
  const weekNumber = 1 + Math.ceil((firstThursday - target.valueOf()) / 604800000)
  return weekNumber
}

